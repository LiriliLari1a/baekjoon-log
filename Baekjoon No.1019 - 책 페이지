# Baekjoon No.1019 - 책 페이지

- [문제 링크](https://www.acmicpc.net/problem/1019)


## 문제 설명 Problem Description
전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 N 페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.
첫째 줄에 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.
첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.

There is a book with a total of N pages. The first page is numbered 1, and the last page is numbered N.
Your task is to count how many times each digit (0 through 9) appears in all page numbers.
The first line contains a single integer N (1 ≤ N ≤ 1,000,000,000).
Print ten integers separated by spaces.
The i-th number should represent how many times the digit i appears in the page numbers from 1 to N.


## 생각 과정 Thought Process
1. ** 수학 - 누적 테이블 **
입력의 범위가 1,000,000,000까지 이기 때문에 O(logN) 으로 해결 할 수 있는 방법을 생각해 내어야 했다.
그래서 exponential하게 반복되는 수의 규칙성에 대해 찾아내었다.
10^n - 1(자릿수가 변화 할 때) 마다 숫자 요소의 개수에 반복되는 패턴이 있었는데 그것을 이용하여 각 자릿수별 누적 테이블을 생성했다(코드 참고).
누적 테이블을 이용하여 결과에 미리 저장해서 시작하면 구할 범위를 [1, N] 에서 [10 ** exp, N] 으로 간소화 할 수 있다.

2. ** 수학 - 메인 처리 **
이 문제를 풀 때 내가 짚은 가장 중요한 포인트는 자릿수별 처리이다.
수학적 패턴을 찾으며 함께 알아낸 방법인데 구해야 하는 큰 범위를 미리 구해놓고 간소화 하는 것이다.
만약 N = 4321을 처리 해야 한다면 미리 구해놓은 누적테이블이 있으므로 구해야 하는 범위는 [1000, 4321] 이며 이 과정에서 앞자리 고정 보정을 이용하는데:
[1000, 1999]
[2000, 2999]
[3000, 3999]
을 따로 구하면 쉽게 각 수의 요소 개수를 셀수 있다. 이후에 보는 자릿수를 변경 하고 이전 자릿수의 수를 고정한다(pinned = [4]).
[4000, 4099]
[4100, 4199]
[4200, 4299]
를 구한 후 자릿수를 변경 후 이전 수를 고정(pinned = [4, 3]).
[4300, 4319]
그리고 (pinned = [4, 3, 2])
[4320, 4321] 은 따로 구한다. 이 범위의 크기는 N이 어떤 수이든 10 이내이다.

3. ** 수학 -  counting 로직 및 고정 보정 **
누적 테이블 이용후 가장 높은 자릿수를 먼저 처리 한후 그 뒤로 십의 자리 까지 for 루프로 처리하고 일의 자리수를 따로 다시 처리했다.
이렇게 한 이유는 가장 높은 자릿수는 그 뒷자리 수 부터 십의 자리까지 0을 값으로 가질 수 없으며 일의 자리에서는 따로 반복성을 가져 오지 않아도 가볍게 처리할 수 있기 때문이다.
고정 보정을 한 이유는 메인 로직에서 수의 등장 을 셀 때 현재 보고 있는 자릿수보다 높은 자릿수의 등장 개수는 세지 않았기 때문이다.
고정 되기 전의 수는 계속 바뀌고 규칙성이 있으므로 고정 보정을 한 수를 계속 더하려고 하면 규칙성을 헤치기 때문에 마지막에 한번에 따로 처리해줬다.
위의 N = 4321 을 다시 가져와서
pinned = [4] 일 때 [4000, 4299]를 모두 처리 후 pinned 된 자릿수의 수는 총 300(100 * 3)개 등장한다.
pinned = [4, 3] 일 때 [4300, 4319]를 모두 처리 후 pinned 된 자릿수의 수는 각 각 총 20(10 * 2)개 등장한다.
pinned = [4, 3, 2] 일 때 [4320, 4321]를 모두 처리 후 pinned 된 자릿수의 수는 각 각 총 2(1 * 2) 개 등장한다.
이런 식으로 자릿수를 고정 후 따리 처리 해 주었다.

1. ** Mathematics – Accumulation Table **
Since the input range can be as large as 1,000,000,000, I needed a method that works in O(logN).
I discovered that the frequency of digits follows an exponential repetitive pattern. Specifically, at each boundary of 10^n - 1 (when the digit length increases), the occurrence of digits repeats in a predictable way.
Using this property, I built an accumulation table for each digit position (see code).
By starting with the precomputed table, the counting range can be simplified from [1, N] to [10^exp, N].

2. ** Mathematics – Main Processing **
The most important point I identified was digit-wise processing.
The idea is to simplify the large range by leveraging the precomputed table and then adjusting the remaining part.
For example, if N = 4321, the accumulation table already covers up to 999. Therefore, I only need to process [1000, 4321].
To handle this, I split the range by fixing the leading digit step by step:
[1000, 1999]
[2000, 2999]
[3000, 3999]
Then, I fix the first digit (pinned = [4]) and move to the next digit:
[4000, 4099]
[4100, 4199]
[4200, 4299]
After that, I fix another digit (pinned = [4, 3]):
[4300, 4319]
And finally (pinned = [4, 3, 2]):
[4320, 4321]
This last range is always very small (less than 10), no matter what N is.

3. ** Mathematics – Counting Logic and Fixed Digit Adjustment **
After using the accumulation table, I processed the highest digit first, then continued with the lower digits (down to the tens place) in a loop, and finally handled the units place separately.
The reason for this design is:
The highest digit cannot have zero as a valid leading digit.
For the unit digit, it is simpler to count directly without relying on the same repetition logic.
The fixed digit adjustment (pinned) is necessary because when processing a digit position, the occurrences of higher fixed digits are not automatically counted.
Before fixing, digits follow a repetitive pattern, but once a digit is fixed, its occurrences must be counted explicitly, otherwise the results would be underestimated.
Using the same example N = 4321:
With pinned = [4], after handling [4000, 4299], the digit 4 appears 300 times (100 × 3).
With pinned = [4, 3], after handling [4300, 4319], the digits 4 and 3 each appear 20 times (10 × 2).
With pinned = [4, 3, 2], after handling [4320, 4321], the digits 4, 3, and 2 each appear 2 times (1 × 2).
In this way, each fixed digit was handled and accumulated step by step.


##코드 설명 Code

```python
N = int(input())
count = [0] * 10
exp = 0
temp = N

# N의 자릿수를 구함
while temp >= 10:
  temp //= 10
  exp += 1

table = [[0] * 10 for _ in range(exp)]
# 자리수 별 숫자 등장 횟수 누적 테이블 생성
for i in range(exp):
  power, base = i, 10 ** i
  # 최좌측 자리
  for num in range(1, 10):
    table[i][num] += base
  if i == 0:
    continue
  # 나머지 자리
  for num in range(10):
    table[i][num] += (base - base // 10) * power + table[i - 1][num]

table = [[0] * 10] + table   # exp == 0 일때 빈리스트 복사를 방지
count = table[-1][:]         # count 초기값 설정
                             # 구할 범위를 (1 ~ N 에서 10 ** exp ~ N 으로 바꿈)
pinned = []                  # 앞자리 고정 보정 리스트
temp = N
if not exp == 0:
  # 가장 높은 자릿수 부터 처리
  # 가장 높은 자릿수가 0인 경우가 없으므로 따로처리
  current = temp // 10 ** exp   # 현재 보고 있는 수
  temp -= current * 10 ** exp   # temp 업데이트
  # exp하게 생기는 규칙성으로 만든 수열을 적용
  for num in range(10):
    count[num] += (current - 1) * exp * (10 ** (exp - 1))
  # 현재 자릿수의 수 등장 개수
  for num in range(1, current):
    count[num] += 10 ** exp
  # 현재 수 고정
  pinned.append(current)
  # 나머지 자릿수 부터 십의 자릿수까지 처리
  for i in range(exp - 1, 0, -1):
    current = temp // 10 ** i   # 현재 보고 있는 수
    temp -= current * 10 ** i   # temp 업데이트
    # exp하게 생기는 규칙성으로 만든 수열을 적용
    for num in range(10):
      count[num] += (current) * i * (10 ** (i - 1))
     # 현재 자릿수의 수 등장 개수
    for num in range(current):
      count[num] += 10 ** i
    # 앞자리 고정 보정
    for pin in pinned:
      count[pin] += current * (10 ** i)
    # 현재 수 고정
    pinned.append(current)

# "0" 제거
else:   
  count[0] -= 1

# 일의 자릿수 수 보정 및 세기
for pin in pinned:
  count[pin] += (temp + 1)
for i in range(temp + 1):
  count[i] += 1

# 출력
for i in range(10):
  print(count[i], end = " ")


## 예시 입력 Sample Input
543212345

## 예시 출력 Sample Output
429904664 541008121 540917467 540117067 533117017 473117011 429904664 429904664 429904664 429904664 


## 마무리 Conclusion or Reflection
이 문제를 풀고 디버깅 하는 과정에서 많은 시간이 소요되었다.
상당히 어렵다고 느껴질 정도로 테스트 케이스에 대해 정확한 답이 도출되기 까지 많은 시간이 걸렸고 많은 수식에 머리가 아팠다.
하지만 결국 디버깅과 오타를 고친 후 나의 수를 세는 계획은 맞았고 이 문제를 통과했다.

It took me a lot of time to solve and debug this problem.
I felt it was quite difficult, and it took a long time until the code produced the correct answers for all test cases.
The many formulas and calculations gave me a headache.
However, after carefully debugging and fixing typos, I confirmed that my counting plan was correct, and I was able to pass the problem.
