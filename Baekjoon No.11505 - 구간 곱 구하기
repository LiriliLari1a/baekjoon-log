# Baekjoon No.11505 - 구간 곱 구하기

- [문제 링크](https://www.acmicpc.net/problem/11505)

## 문제 설명 Problem Description
첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다.
M은 수의 변경이 일어나는 횟수이고, K는 구간의 곱을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다.
그리고 N+2번째 줄부터 N+M+K+1 번째 줄까지 세 개의 정수 a,b,c가 주어지는데, a가 1인 경우 b번째 수를 c로 바꾸고 a가 2인 경우에는 b부터 c까지의 곱을 구하여 출력하면 된다.
입력으로 주어지는 모든 수는 0보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.
첫째 줄부터 K줄에 걸쳐 구한 구간의 곱을 1,000,000,007로 나눈 나머지를 출력한다.

You are given three integers on the first line: N (1 ≤ N ≤ 1,000,000), M (1 ≤ M ≤ 10,000), and K (1 ≤ K ≤ 10,000).
N is the number of elements.
M is the number of update operations.
K is the number of product queries.
On the next N lines (from the 2nd to the (N+1)-th line), you are given the initial N numbers.
From line N+2 to line N+M+K+1, each line contains three integers a, b, c.
If a = 1, it means you must update the b-th number to the value c.
If a = 2, you must compute the product of the numbers in the range from index b to index c (inclusive) and output the result modulo 1,000,000,007.
All numbers given in the input are integers between 0 and 1,000,000 (inclusive).
Your task is to output the results of the K product queries, one per line.


## 생각 과정 Thought Process
1. ** 세그먼트 트리 **
구간합에서 사용 했던 세그먼트 트리를 이용하면 되겠다고 생각했다.
구간합과 다르게 사용해야 하는 점은 저장 및 출력 그리고 계산 할때 마다 MOD 연산을 꾸준히 넣어주어야 하고
쿼리를 구할 때 구간곱 범위에 포함되지 않는 경우에는 0이 아닌 1을 반환해야 한다.

1. ** Segment Tree **
I thought I could use the segment tree I had studied for range sums.
Unlike with range sums, the key differences here are in storage, output, and consistently applying the MOD operation during every calculation.
Also, when handling queries, if the range does not overlap with the product range, I must return 1 instead of 0.


##코드 설명 Code

```python
MOD = 1_000_000_007

N, M, K = map(int, input().split())
tree = [0] * (N * 4)

# 수열 입력
numbers = [0] * N
for i in range(N):
  numbers[i] = int(input())

# 세그먼트 트리 작성
def build(node, start, end):
  if start == end:
    tree[node] = numbers[start]
  else:
    mid = (start + end) // 2
    build(node * 2, start, mid)
    build(node * 2 + 1, mid + 1, end)
    tree[node] = ((tree[node * 2] % MOD) * (tree[node * 2 + 1] % MOD)) % MOD

# 쿼리를 구함
def query(node, start, end, left, right):
  # 범위에 포함되지 않을 때 기본값 : 1
  if right < start or end < left:
    return 1
  # 범위에 모두 포함 될 때
  if left <= start and end <= right:
    return tree[node]
  mid = (start + end) // 2
  l_mult = query(node * 2, start, mid, left, right)
  r_mult = query(node * 2 + 1, mid + 1, end, left, right)
  return ((l_mult % MOD) * (r_mult % MOD)) % MOD

# 트리 값 업데이트
def update(node, start, end, idx, val):
  if start == end:
    numbers[idx] = val
    tree[node] = val
  else:
    mid = (start + end) // 2
    if idx <= mid:
      update(node * 2, start, mid, idx, val)
    else:
      update(node * 2 + 1, mid + 1, end, idx, val)
    tree[node] = ((tree[node * 2] % MOD ) * (tree[node * 2 + 1] % MOD)) % MOD

build(1, 0, N - 1)

for _ in range(M + K):
  a, b, c = map(int, input().split())
  if a == 1:
    update(1, 0, N - 1, b - 1, c)
  else:
    print(query(1, 0, N - 1, b - 1, c - 1))


## 예시 입력 Sample Input
5 2 2
1
2
3
4
5
1 3 0
2 2 5
1 3 6
2 2 5
## 예시 출력 Sample Output
0
240


## 마무리 Conclusion or Reflection
구간합을 구하는 방법을 알고 있다면 어려운 문제는 아니다. 다만 구간 합과 다른 차이 때문에 0이 계속 출력되길래 왜그럴까 잠깐 생각해봤지만 쉽게 찾아냈다.

If you already know how to compute range sums, this problem is not difficult.
However, because of the difference from sums, I kept getting 0 as the output and wondered why for a moment—but I quickly figured it out.
