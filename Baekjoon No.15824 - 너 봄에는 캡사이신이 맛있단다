# Baekjoon No.15824 - 너 봄에는 캡사이신이 맛있단다

- [문제 링크](https://www.acmicpc.net/problem/15824)

## 문제 설명 Problem Description
예를 들어 [5, 2, 8]의 스코빌 지수를 가진 음식을 먹을 때 주헌이가 느끼는 매운 정도는 가장 높은 수치인 8과 가장 낮은 수치인 2의 차이인 6만큼의 매운맛을 느낀다. 
이처럼 메뉴들의 스코빌 지수가 있을 때 그 최댓값과 최솟값의 차이를 "주헌고통지수"라고 정의한다.
주헌이의 목표는 이 음식점의 모든 음식 조합을 먹어보는 것이다. 하지만 주헌이는 까다로워서 한 번 먹어본 조합은 다시 먹지 않는다.
이 음식점의 모든 조합을 먹어 볼 때 주헌이가 즐길 수 있는 주헌고통지수의 합을 구해보자.
첫 줄에 메뉴의 총 개수 N이 주어진다. 두 번째 줄에는 N개의 메뉴의 스코빌 지수가 주어진다. 모든 스코빌 지수는 0보다 크거나 같고 231-1보다 작거나 같은 정수이다.
한 줄에 모든 조합의 주헌고통지수 합을 1,000,000,007로 나눈 나머지를 출력한다.

Juheon is trying out various combinations of dishes, each with a certain Scoville score representing how spicy it is.
For example, if Juheon eats a combination of dishes with Scoville scores [5, 2, 8], the spiciness Juheon feels is defined as the difference between the highest and lowest Scoville scores in the combination.
So, in this case, the spiciness he feels is 8 - 2 = 6.
Let’s define this value as the "Juheon Pain Index" of the combination.
Juheon’s goal is to try every possible non-empty combination of the menu items without repetition (i.e., he never eats the same combination twice).
Given the list of dishes and their Scoville scores, calculate the sum of the Juheon Pain Index across all possible combinations, and print the result modulo 1,000,000,007.
The first line contains an integer N (1 ≤ N ≤ 100,000), the number of menu items.
The second line contains N integers: the Scoville scores of the dishes.
Each score is a non-negative integer, and all scores are ≤ 2³¹ − 1.
Output a single line: the total sum of Juheon Pain Index values over all possible non-empty combinations, modulo 1,000,000,007.


## 생각 과정 Thought Process
1. ** 정렬 **
일단 모든 입력값에 대해 최소값과 최대값을 기반으로 계산을 해야 하므로 모든 값에 대해 오름차순으로 정렬하였다.

2. ** 수학 **
처음에는 무작정 풀려하다가 시간초과날게 뻔한 방법들 밖에 떠오르지 않아서 아이패드에 규칙성을 적어나가 보았다.
최소값 a와 최대값 b를 포함하는 조합의 개수 기반으로 규칙성을 찾았는데 number은 sort() 된 해당 수열이라고 할때:
  
N = 2  { result = -number[0] * 2^0 + number[1] * 2^0 }

N = 3  { result = -number[0] * (2^0 + 2^1) + number[1] * 0 + number[2] * (2^0 + 2^1)

N = 4  { result = -number[0] * (2^0 + 2^1 2^2) - number[1] * (2^1) + number[2] * (2^1) + number[3] * (2^0 + 2^1 2^2) }

N = 5  { result = -number[0] * (2^0 + 2^1 2^2 + 2^3) - number[1] * (2^1 + 2^2) + number[2] * (0) + number[3] * (2^1 2^2) + number[4] * (2^0 + 2^1 2^2 + 2^3) }

...

언뜻 보면 규칙성을 찾기 어렵지만 N 이 홀수이면 가장 가운데 있는 값이 양측값의 보합으로 무시되며 양측 사이드 부터 중앙으로 모이며 좌측은 음의값, 우측은 양의값으로
∑ (i = 0 to N-2) 2^i    (-number[0], number[-1])
∑ (i = 1 to N-3) 2^i    (-number[1], number[-2])
∑ (i = 2 to N-4) 2^i    (-number[2], number[-3])
∑ (i = 3 to N-5) 2^i    (-number[3], number[-4])
...
이런 규칙성을 갖는다. 이런 규칙성을 이용하여 exp_sum을 계산했으며 exp_sum의 계산 효율성을 위해 2의 제곱수를 N의 길이만큼 저장한 exp 리스트를 만들었다.
그후 차례대로 알맞게 연산하면 된다.


1. ** Sorting **
Since the calculation relies on both the minimum and maximum values from every combination, I sorted the input list in ascending order.

2. ** Mathematical Insight **
At first, I tried to approach the problem directly, but it was clear that the naive method would result in a time limit exceeded error. So, I started looking for a pattern by writing down examples and analyzing them on my iPad.
I focused on the number of combinations that include a particular element as either the minimum or maximum value. Let's say the sorted list is called number.

For N = 2:
result = -number[0] * 2^0 + number[1] * 2^0

For N = 3:
result = -number[0] * (2^0 + 2^1) + number[1] * 0 + number[2] * (2^0 + 2^1)

For N = 4:
result = -number[0] * (2^0 + 2^1 + 2^2) - number[1] * 2^1 + number[2] * 2^1 + number[3] * (2^0 + 2^1 + 2^2)

For N = 5:
result = -number[0] * (2^0 + 2^1 + 2^2 + 2^3) - number[1] * (2^1 + 2^2) + number[2] * 0 + number[3] * (2^1 + 2^2) + number[4] * (2^0 + 2^1 + 2^2 + 2^3)

At a glance, it seems difficult to identify the pattern. But I noticed that if N is odd, the middle element is effectively neutralized, 
while the elements from both sides mirror each other — the left side contributes negatively, and the right side contributes positively.
This results in a pattern like:

∑ (i = 0 to N-2) 2^i         → (-number[0], number[-1])
∑ (i = 1 to N-3) 2^i         → (-number[1], number[-2])
∑ (i = 2 to N-4) 2^i         → (-number[2], number[-3])
...
Using this pattern, I calculated the exp_sum (sum of powers of two for each layer from both ends). 
To optimize this further, I precomputed all powers of two in an exp list of length N. This helped reduce redundant calculations.
Once the exp_sum was ready, I simply applied it in the corresponding order to the sorted number list to compute the final result.


##코드 설명 Code

```python
MOD = 1_000_000_007

N = int(input())

numbers = list(map(int, input().split()))
numbers.sort()

# 2의 제곱수 리스트
exp = [1] * N
for i in range(1, N):
  exp[i] = (exp[i - 1] * 2) % MOD

# 해당 문제의 규칙성을 기반으로 한 2의 제곱수 sigma 리스트
exp_sum = [0] * ((N + 1) // 2)
exp_sum[0] = exp[-1] - 1
for i in range(1, len(exp_sum)):
  exp_sum[i] = (exp_sum[i - 1] - exp[i - 1] - exp[N - 1 - i])

# sigma 리스트를 이용하여 결과 계산
result = 0
for i in range(len(exp_sum)):
  result += (exp_sum[i] * (numbers[-i - 1] - numbers[i])) % MOD

print(result % MOD)


## 예시 입력 Sample Input
7
1 984 -5 1234 7 -45678 1

## 예시 출력 Sample Output
2985198

## 마무리 Conclusion or Reflection
수학관련 문제를 좋아해서 재미있게 풀어본 문제이다. 노트에 적으면서 규칙성에 대한 아이디어는 빨리 나왔지만 최적화 과정에서는 조금 까다로웠다.
처음에는 제곱연산이 그렇게 무거울지 몰랐다. 이후에 많은 제곱연산을 사용해야 할때는 제곱연산이 미리 처리된 리스트를 사용할 예정이다.

I really enjoyed this problem because it was heavily math-focused. The idea for the pattern came to me fairly quickly while working it out on paper, but the optimization part was a bit tricky.
Initially, I underestimated the cost of repeated exponentiation. Going forward, I’ll make it a habit to precompute powers when multiple exponentiations are required.
