# Baekjoon No.1761 - 정점들의 거리

- [문제 링크](https://www.acmicpc.net/problem/1761)

## 문제 설명 Problem Description
N(2 ≤ N ≤ 40,000)개의 정점으로 이루어진 트리가 주어지고 M(1 ≤ M ≤ 10,000)개의 두 노드 쌍을 입력받을 때 두 노드 사이의 거리를 출력하라.
첫째 줄에 노드의 개수 N이 입력되고 다음 N-1개의 줄에 트리 상에 연결된 두 점과 거리를 입력받는다. 
그 다음 줄에 M이 주어지고, 다음 M개의 줄에 거리를 알고 싶은 노드 쌍이 한 줄에 한 쌍씩 입력된다. 두 점 사이의 거리는 10,000보다 작거나 같은 자연수이다.
정점은 1번부터 N번까지 번호가 매겨져 있다.
M개의 줄에 차례대로 입력받은 두 노드 사이의 거리를 출력한다.

You are given a tree with N vertices (2 ≤ N ≤ 40,000). You will also be given M pairs of nodes (1 ≤ M ≤ 10,000). For each pair, you must output the distance between the two nodes.
The first line contains the number of nodes, N.
The next N − 1 lines each contain three integers: two vertices connected by an edge and the distance (a positive integer ≤ 10,000) between them.
The next line contains the number of queries, M.
Each of the following M lines contains two integers, representing a pair of nodes for which you must find the distance.
The vertices are numbered from 1 to N.
Output M lines, each containing the distance between the corresponding pair of nodes.


## 생각 과정 Thought Process
1. ** 루트로부터의 거리 **
일단 거리를 구할 때 두개의 노드를 입력 받을 때 마다 노드를 하나씩 옮겨가며 거리의 누적을 구하는 것은 비효율적이라고 생각했다.
그래서 임의의 루트노드를 정하고 그 루트노드로부터의 거리를 weight 리스트에 구해놓았다.

2. ** 최소 공통 조상 - 1 **
루트노드를 정했으므로 그것을 토대로 이진트리를 작성 할 수 있게 되었다.
처음에는 1차원 리스트로 부모노드 저장 트리를 완성 한후 재귀로 최소 공통 조상을 찾았다.
하지만 시간초과 결과를 받아서 알아본 결과 이를 2차원 리스트로 만들고 2^n번째 부모노드를 미리 저장해 놓으면 된다는 것을 배웠다.

3. ** 최소 공통 조상 - 2 **
그리고 정형화된 최소 공통 조상을 구하는 방법이 있다는 것을 알았다. 여러번 제출했지만 계속 틀려서 이를 따르기로 했다.
입력 받은 두 노드의 깊이 차이를 구하고 비트연산으로 그 차이값을 2^n + 2^(n-1) + ... + 2^0 으로 쪼갠다.
그리고 미리 만들어둔 2차원 부모노드 리스트로 O(logN) 시간으로 점프하여 두 노드 서로의 깊이를 맞춘다.
깊이를 맞춘 후 가장 큰 점프부터 최소 공통 조상을 찾는 점프를 시작하는데 이것을 이해하는데에 좀 시간이 걸렸다.
왜 큰 점프부터 시작해야 하는지 그리고 왜 parent[0][u] 를 리턴하는지 하나씩 차근차근 보며 이해했다.
처음에는 가장 큰 점프로 둘의 공통 조상이 같다면 점프 하지 않고 다르다면 점프한다.
같은 방법으로 두번째는 두번째로 큰 점점프로 서서히 점프의 크기를 줄이며 세밀하게 최소 공통 조상을 찾아 나간다.

1. ** Distance from the Root **
When computing distances, it’s inefficient to move step by step for every queried pair and accumulate the distance each time.
Instead, I pick an arbitrary root node and precompute the distance from that root to every node, storing it in an array weight.

2. ** Lowest Common Ancestor — I **
Once the root is fixed, I can build the data needed for binary lifting.
At first, I kept only a 1-D parent array (the immediate parent of each node) and tried to find the LCA by recursively climbing up.
This led to a time-limit exceeded result. I then learned that if I use a 2-D table and precompute each node’s 2^k-th ancestor, I can speed things up significantly.

3. ** Lowest Common Ancestor — II **
There’s a standard method to compute the LCA efficiently. After multiple wrong submissions, I decided to follow it closely.
For a queried pair, I first take the depth difference and decompose it with bit operations into 2^n + 2^(n−1) + ... + 2^0. 
Using the precomputed 2-D ancestor table, I “jump” upward in O(logN) time to match the depths of the two nodes.
After aligning depths, the search for the LCA proceeds from the largest jump size downward.
It took me a bit to internalize why we start from the largest jump and why we finally return parent[0][u]. 
The idea is: at each step, if the 2^k-th ancestors of the two nodes differ, we lift both by 2^k.
Repeating this from large to small jumps brings both nodes to just below the LCA. At that point, their immediate parent (parent[0][u]) is the LCA.


##코드 설명 Code

```python
# 2^16 = 65,536(bigger than 40,000)
LOG = 16

# 부모노드, 깊이, 가중치 업데이트
def dfs(a, b):
  for v, w in graph[a]:
    if v != b:
      parent[0][v] = a
      depth[v] = depth[a] + 1
      weight[v] = weight[a] + w
      dfs(v, a)

N = int(input())
# 양방향 그래프로 저장
graph = { i : [] for i in range(1, N + 1) }
for _ in range(N - 1):
  u, v, w = map(int, input().split())
  graph[u].append((v, w))
  graph[v].append((u, w))
root = 1    # 임의 루트 1

parent = [[0] * (N + 1) for _ in range(LOG)]    # 부모 노드 저장 트리(이진 점프를 위해 2차원 행렬 구성)
depth = [0] * (N + 1)                           # 노드의 깊이
weight = [0] * (N + 1)                          # 루트 노드로 부터의 가중치
dfs(1, 0)

# 공통 조상 노드를 반환
def lca(u, v):
  if depth[u] < depth[v]:   # 정렬
    u, v = v, u
  diff = depth[u] - depth[v]  # 깊이 차이

  for i in range(LOG):    # 비트 단위로 쪼개어 O(logN)의 시간으로 점프
    if diff & (1 << i):
      u = parent[i][u]

  if u == v:    # 공통 조상 노드 발견
    return u
  for i in reversed(range(LOG)):    # 가장 큰 점프 부터 처리
    if parent[i][u] != parent[i][v]:
      u = parent[i][u]
      v = parent[i][v]
  return parent[0][u]

# 이진 점프 행렬 구성
for i in range(1, LOG):
  for j in range(1, N  +1):
    parent[i][j] = parent[i - 1][parent[i - 1][j]]

M = int(input())
for _ in range(M):
  a, b = map(int, input().split())
  print(weight[a] + weight[b] - 2 * weight[lca(a, b)])


## 예시 입력 Sample Input
7
1 6 13
6 3 9
3 5 7
4 1 3
2 4 20
4 7 2
1 6
1 4
3
2 6

## 예시 출력 Sample Output
3
13
36

## 마무리 Conclusion or Reflection
조금 까다로운 문제였다. parent 배열도 조금 생소 했고 lca라는 로직을 처음 배워보며 이해하기에도 조금 시간이 걸렸다.
처음의 나의 접근법도 유효 했지만 틀린게 아닌 시간초과가 난걸로 봐서 아주 크게 다른 로직은 아닌 것 같다.
이런 테스트케이스가 많은 문제에서 이를 응용하여 다음에 사용 할 수 있을 것 같다.

It was a rather tricky problem. The parent array itself felt a bit unfamiliar, and since it was my first time learning the LCA technique, it took me some time to fully understand it.
My initial approach was still valid; the issue wasn’t correctness but rather a time-limit exceeded error, so in hindsight, the logic wasn’t fundamentally wrong.
For problems with many test cases like this one, I think I can apply what I’ve learned here more effectively in the future.
