# Baekjoon No.1786 - 찾기

- [문제 링크](https://www.acmicpc.net/problem/1786)


## 문제 설명 Problem Description
첫째 줄에 문자열 T가, 둘째 줄에 문자열 P가 주어진다. T와 P의 길이 n, m은 1이상 100만 이하이고, 알파벳 대소문자와 공백으로만 이루어져 있다.
첫째 줄에, T 중간에 P가 몇 번 나타나는지를 나타내는 음이 아닌 정수를 출력한다. 둘째 줄에는 P가 나타나는 위치를 차례대로 공백으로 구분해 출력한다.
예컨대, T의 i～i+m-1번 문자와 P의 1～m번 문자가 차례로 일치한다면, i를 출력하는 식이다.

You are given two strings, T and P. The first line contains the string T. The second line contains the string P.
The lengths of T and P, denoted by n and m, satisfy 1 ≤ n, m ≤ 1,000,000.
Both T and P consist only of uppercase and lowercase English letters and spaces.
On the first line, print the number of times that P appears in T.
On the second line, print the starting positions (indices) of each occurrence, in ascending order, separated by spaces.
The index i should be printed if the substring T[i ... i+m-1] matches P[1 ... m].
Indices are 1-based.


## 생각 과정 Thought Process
1. ** 큐와 동적계획법 **
처음 kmp 알고리즘을 알지 못할 때 큐와 동적계획법을 이용하여 접근했다.
for 루프로 T를 돌며 큐 안에 현재 P와 일치 할 수 있는 후보를 저장해두고 일치했거나 후보가 될 가능성이 없는 것들을 pop했다.
겉으로는 빠른 알고리즘 같아 보였으나 시간초과를 받았다.

2. ** kmp **
이 문제를 풀기 위해선 무조건 kmp 알고리즘이나 라빈 카프 알고리즘을 공부해야했다.
kmp 알고리즘을 공부해 보았는데 꽤나 까다로운 알고리즘이었지만 동시에 흥미로운 알고리즘 이었다.
kmp 알고리즘은 P의 부분일치 테이블(실패 함수)를 작성하여 T안에서 for 루프를 돌며 찾기에 실패 했을 때 이전 가능한 접두사로 이전할수 있게 만드는 알고리즘이다.
이에 관련한 블로그를 둘러보며 코드는 간단하지만 풀어 헤쳐보면 정교하게 만들었다는 생각이 들었다.

1. ** Queue and Dynamic Programming **
When I first encountered this problem, I didn’t know about the KMP algorithm, so I tried to approach it using a queue and dynamic programming.
While looping through T, I stored the current candidates that could potentially match P in a queue, and popped them out once they either matched fully or could no longer be valid candidates.
At first glance, it looked like a fast algorithm, but in the end, it resulted in a time limit exceeded.

2. ** KMP **
To solve this problem properly, I had to study either the KMP algorithm or the Rabin–Karp algorithm.
I chose to learn KMP, and although it turned out to be a rather tricky algorithm, it was also quite fascinating.
The KMP algorithm constructs a partial match table (failure function) for P, and while scanning through T with a loop, it allows us to fall back to the longest possible prefix whenever a mismatch occurs.
After reading several blog posts about it, I realized that while the code itself looks fairly simple, the underlying logic is very carefully crafted.


##코드 설명 Code

```python
# P의 부분 일치 테이블(실패 함수) 작성
def kmp_table():
  level = 0
  table = [0] * (len(P))
  for i in range(1, len(P)):
    while level > 0 and P[i] != P[level]:
      level = table[level - 1]
    if P[level] == P[i]:
      level += 1
      table[i] = level

  return table

T = input()
P = input()
table = kmp_table()
LP = len(P)

j = 0   # P 안에서의 인덱스
result = []   # 결과 저장
for i in range(len(T)):
  # 이전 가능한 접두사로 이전
  while j > 0 and T[i] != P[j]:
    j = table[j - 1]
  if T[i] == P[j]:
    # 찾기 성공
    if j == LP - 1:
      result.append(i - LP + 2)
      j = table[j]
    else:
      j += 1
print(len(result))
print(' '.join(str(x) for x in result))


## 예시 입력 Sample Input
ABC ABCDAB ABCDABCDABDE
ABCDABD

## 예시 출력 Sample Output
1
16


## 마무리 Conclusion or Reflection
문자열에 대한 문제 자체가 굉장히 유니크한 문제여서 이쯤되면 만나지 않을줄 알아서 기본적인 테크닉 밖에 몰랐는데 이런 고급 알고리즘을 겪어보니 쉽지 않았다.
이 알고리즘이 역사가 꽤나 있다고 했는데 그에비해 굉장히 똑똑한 알고리즘이고 배울만한 가치가 있는 알고리즘이었다.

This type of string problem felt very unique to me. Up until now, I thought I wouldn’t run into such problems often, so I only knew the basic techniques. 
But encountering this advanced algorithm firsthand made me realize it’s not easy at all.
I also learned that this algorithm has quite a history behind it, and considering how smartly it was designed, I think it’s definitely an algorithm worth learning.
