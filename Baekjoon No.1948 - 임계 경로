# Baekjoon No.1948 - 임계 경로

- [문제 링크](https://www.acmicpc.net/problem/1948)

## 문제 설명 Problem Description
월드 나라는 모든 도로가 일방통행인 도로이고, 싸이클이 없다. 그런데 어떤 무수히 많은 사람들이 월드 나라의 지도를 그리기 위해서, 
어떤 시작 도시로부터 도착 도시까지 출발을 하여 가능한 모든 경로를 탐색한다고 한다.
이 지도를 그리는 사람들은 사이가 너무 좋아서 지도를 그리는 일을 다 마치고 도착 도시에서 모두 다 만나기로 하였다. 
그렇다고 하였을 때 이들이 만나는 시간은 출발 도시로부터 출발한 후 최소 몇 시간 후에 만날 수 있는가? 즉, 마지막에 도착하는 사람까지 도착을 하는 시간을 의미한다.
어떤 사람은 이 시간에 만나기 위하여 1분도 쉬지 않고 달려야 한다. 이런 사람들이 지나는 도로의 수를 카운트 하여라.
출발 도시는 들어오는 도로가 0개이고, 도착 도시는 나가는 도로가 0개이다.
첫째 줄에 도시의 개수 n(1 ≤ n ≤ 10,000)이 주어지고 둘째 줄에는 도로의 개수 m(1 ≤ m ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 도로의 정보가 주어진다.
처음에는 도로의 출발 도시의 번호가 주어지고 그 다음에는 도착 도시의 번호, 그리고 마지막에는 이 도로를 지나는데 걸리는 시간이 주어진다. 
도로를 지나가는 시간은 10,000보다 작거나 같은 자연수이다.
그리고 m+3째 줄에는 지도를 그리는 사람들이 출발하는 출발 도시와 도착 도시가 주어진다.
모든 도시는 출발 도시로부터 도달이 가능하고, 모든 도시로부터 도착 도시에 도달이 가능하다.
첫째 줄에는 이들이 만나는 시간을, 둘째 줄에는 1분도 쉬지 않고 달려야 하는 도로의 수가 몇 개인지 출력하여라.

n the country of "World", all roads are one-way (directed) and the network contains no cycles (i.e., it's a DAG – Directed Acyclic Graph).
Countless people are drawing maps by traveling from a specific start city to a specific end city, exploring all possible paths.
After completing their routes, they all gather at the end city.
You are to calculate:
The minimum time after which everyone can meet at the end city.
(This is the longest time it takes for any person starting at the start city and reaching the end city via a valid path — i.e., the longest path from start to end.)
The number of roads (edges) that are part of at least one longest path,
and therefore must be traveled by people who arrive exactly at the meeting time (i.e., without resting even for a minute).
input:
n — number of cities (1 ≤ n ≤ 10,000)
m — number of roads (1 ≤ m ≤ 100,000)
Next m lines — each road:
u v t — a one-way road from city u to city v, taking t minutes
Final line: start end — the start and end cities
output:
First line: The maximum time required to reach the end city from the start
Second line: The number of roads that are used in any of the longest paths


## 생각 과정 Thought Process
1. ** 위상정렬 **
처음 이 문제를 보고 위상정렬을 떠올리는 것은 쉽지 않았다. 하지만 사이클이 없다는 힌트를 보고 위상정렬을 떠올렸다.

2. ** 너비우선탐색 **
위상정렬을 이용하여 너비우선탐색을 실시하였다.
이 문제에서 구해야 하는 요소는 가장 나중에 도착하는 사람이 걸린 시간과 그 경로인데 걸린 시간은 최종 한개지만
경로는 하나가 될수도 있고 둘 이상이 될수도 있으므로 이전경로는 여러개로 저장할 수 있도록 딕셔너리 세트를 이용하였다.

3. ** 걸린 시간 **
걸린 시간을 구하는 것은 어렵지 않았다. end에서 출발하여 start까지 도착할때 경유하는 지점중 최대로 걸리는 시간을 구하였다.
이것이 가능한 이유는 사이클이 없기 때문이었고 다른경로로 걸리는 시간이 갱신되어 기존 시간과 더 큰 시간을 max()를 이용하여 저장했다.

4. ** 경로 **
경로를 구하는 것은 조금 까다로웠다. 백트래킹을 위해 일부러 start -> end 가 아닌 end -> start로 미리 구해놨고 도로도 반대로 접근할수 있도록 설정했다.
걸린 시간을 구하며 그 시간이 기존 시간보다 커서 업데이트 될때 해당 위치의 이전 경로를 모두 삭제하고 업데이트 했으며 
기존 시간과 새로 구해진 시간이 같으면 기존 이전경로에 더해서 다른 경로까지 저장했다.
이때 다른 경로를 추가로 저장할때 중복으로 저장하는 것을 방지하기위해 set() 를 사용하였다.
이전 경로가 모두 저장되었으면 start 위치 부터 저장된 이전 경로를 end 위치 까지 따라가며 도달하는 위치마다 result에 추가했는데
result 또한 set()로 저장하여 중복 위치를 저장하지 않도록 했다.

1. ** Topological Sorting **
At first, it wasn't obvious to apply topological sorting to this problem.
However, the key hint was that the graph has no cycles, which led me to consider topological sorting.

2. ** Breadth-First Search (BFS) **
I applied BFS based on topological order.
In this problem, we need to find:
The time it takes for the last person to arrive at the destination, and
The number of roads used in any of the longest paths.
Since the time is a single maximum value, but the number of paths can vary (there can be multiple longest paths), 
I used a dictionary of sets to store multiple previous nodes that lead to each city.

3. ** Calculating Maximum Time **
Finding the maximum time was not difficult.
I computed the longest time required to go from the start city to the end city by using topological order.
This was possible because the graph is acyclic, allowing the use of a max() operation to update the time for each node when a longer path is found.

4. ** Tracking Paths **
Tracking the actual paths was more complex.
To make backtracking easier, I intentionally processed the graph in reverse (from end to start), and stored edges accordingly.
While computing the longest time:
If a new longer path was found, I cleared the current node's previous paths and stored only the new one.
If a path with the same maximum time was found, I added that additional previous node.
To avoid duplicate entries, I used a set for each node's list of previous nodes.
Once all previous paths were stored, I performed another traversal (from the start city backward using the saved prev data) to collect all edges used in any longest path.
I stored these edges in a result set to ensure uniqueness.


##코드 설명 Code

```python
from collections import deque

# 너비우선탐색기반 위상정렬
def bfs(start, indegree, weight, prev):
  queue = deque([start])
  while queue:
    location = queue.popleft()
    for item in road[location]:
      w, nxt = item
      if weight[nxt] < w + weight[location]:
        weight[nxt] = w + weight[location]
        # 새로운 경로의 시간이 더 오래걸림 -> 기존 데이터 삭제 및 업데이트
        prev[nxt].clear() 
        prev[nxt].add(location)
      # 새로운 경로와 걸리는 시간이 같음 -> 기존 데이터에서 추가
      elif weight[nxt] == w + weight[location]:
        prev[nxt].add(location)
      indegree[nxt] -= 1
      # 진입차수가 0 -> 큐 삽입
      if indegree[nxt] == 0:
        queue.append(nxt)

n = int(input())
m = int(input())

prev = { i : set() for i in range(1, n + 1)}    # 이전 경로 저장
indegree = [0] * (n + 1)    # 진입 차수 저장
weight = [0] * (n + 1)    # 해당 도시에 도착할 떄 걸리는 최대 시간
road = { i : [] for i in range(1, n + 1)}   # 도로 정보 저장
for i in range(m):
  a, b, w = map(int, input().split())
  road[b].append((w, a))
  indegree[a] += 1

start, end = map(int ,input().split())

bfs(end, indegree, weight, prev)
print(weight[start])    # start -> end 최대 걸리는 시간 출력

que = deque([])
result = set()
que.append(start)
while que:
  current = que.popleft()
  # 현재 위치에서 저장된 모든 이전경로
  for next in prev[current]:
    if (current,next) not in result:    # current to next 도로
      que.append(next)
      result.add((current, next))

print(len(result))


## 예시 입력 Sample Input
5
9
1 4 5
1 3 6
3 5 3
2 5 3
2 3 7
1 2 2
1 5 9
3 4 1
5 4 2
1 4

## 예시 출력 Sample Output
14
4


## 마무리 Conclusion or Reflection
지금까지 배웠던 많은 강력한 알고리즘을 사용할 수 있었던 문제였다. 
만약 weight만 구했으면 골드수준의 문제였겠지만 백트래킹을 시도하여 여러 경로를 저장하는 방법에 대해서 생각해보는 것이 조금 어려웠다고 생각한다.
위상정렬과 백트래킹, 그리고 너비우선탐색까지 사용하고 사용하기에 알맞은 자료구조로 변형시키면서 복습과 응용을 함께 배웠다.

It was a problem where I could apply many of the powerful algorithms I’ve learned so far.
If the task had only been to calculate the weight, it would have been at the Gold level.
However, trying to implement backtracking and thinking about how to store multiple paths made it a bit more challenging.
Through this problem, I was able to review and apply various techniques such as topological sorting, backtracking, and breadth-first search.
I also practiced transforming data into appropriate structures depending on the situation.
