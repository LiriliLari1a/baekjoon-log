# Baekjoon No.20149 - 선분 교차 3

- [문제 링크](https://www.acmicpc.net/problem/20149)


## 문제 설명 Problem Description
2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구해보자. 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 것도 교차하는 것이다.
L1의 양 끝 점은 (x1, y1), (x2, y2), L2의 양 끝 점은 (x3, y3), (x4, y4)이다.
첫째 줄에 L1의 양 끝 점 x1, y1, x2, y2가, 둘째 줄에 L2의 양 끝 점 x3, y3, x4, y4가 주어진다.
L1과 L2가 교차하면 첫째 줄에 1, 아니면 0을 출력한다.
두 선분이 한 점에서 교차하는 경우 둘째 줄에 교차하는 점의 x좌표와 y좌표를 공백으로 구분해 출력한다. 한 점에서 교차하지 않는 경우에는 둘째 줄을 출력하지 않는다.
좌표의 절대/상대 오차는 10-9까지 허용한다.

You are given two line segments L1 and L2 on a 2D coordinate plane. Determine whether the two line segments intersect or not.
If one endpoint of a segment lies exactly on the other segment (or its endpoint), it is also considered an intersection.
Let the endpoints of L1 be (x1, y1) and (x2, y2), and the endpoints of L2 be (x3, y3) and (x4, y4).
The first line contains four integers: x1 y1 x2 y2, representing the endpoints of L1.  
The second line contains four integers: x3 y3 x4 y4, representing the endpoints of L2.
Print 1 if the two line segments intersect, otherwise print 0.
If they intersect at exactly one point, print on the second line the coordinates of the intersection point.  
You may output real numbers with absolute or relative error up to 1e-9.
If they do not intersect at a single point (e.g., they are collinear and overlapping), do not print the second line.


## 생각 과정 Thought Process
1. ** CWR (Cross With Rotation) **
선분 교차 2를 구현할때 썼던 나만의 알고리즘인 Cross With Rotation 을 사용하기로했다. 
CCW 보다 더욱 알고리즘적인 움직임이 조금더 해체되어있는 코드인데 따라서 선분의 위치 그리고 선분의 기울기 등을 파악해서 교차점을 판단하기 쉬울것이라고 생각했다.
다만 Cross With Rotation의 코드를 일부 변경하여 shape 라는 변수를 집어넣고 [0 : 한점에서 만날수 없음 / 1 : 한점에서 만날수도 있음 / 2 : 한점에서 만남] 으로 판별했다.
해당 선분들이 모두 만나는지에 관해서는 따로 본래 알고리즘에서 건들지 않았다.
CWR description link - (https://github.com/LiriliLari1a/Algorithmic-Patterns-I-Discovered/blob/main/cross%20with%20rotation)


2. ** 교차점 출력 **
교차점을 출력하려면 어쩔수 없이 float 연산을 사용해야 했다. 
float 연산의 부정확성을 막기위해 알고리즘에서 모든 소숫점이 들어가는 요소를 배제 했는데 어쩔수 없이 마지막에 딱 한번만 나누기 연산을 하는것으로 했다.
두 점으로 일차방정식을 세우고 기초적인 수학으로 x = a / b, y = c / d 형태로 만든 후 마지막에 나눗셈을 실시했다.
shape == 2 일때에는 두 선분의 기울기가 같고 서로 끝점에서 만나는 형태이다.
따라서 같은 점을 공유하고 있는 위치를 찾아 출력했다.

1. ** CWR (Cross With Rotation) **
When implementing Line Segment Intersection 2, I chose to use my own algorithm called Cross With Rotation (CWR).
Unlike the standard CCW (Counter Clock Wise) method, this approach is more "algorithmically decomposed" — 
it breaks down the logic into checking segment positions, slopes, and overlaps, which made it easier for me to reason about intersections.
In this version, I slightly modified the CWR algorithm by introducing a shape variable with the following meaning:
0: The segments cannot intersect at a single point
1: The segments may intersect at exactly one point
2: The segments intersect at exactly one point
The core logic that determines whether the segments intersect remained unchanged from the original CWR algorithm.


2. ** Intersection Point Output **
In order to output the intersection point (when it exists), I had to use floating-point division.
Although the algorithm was carefully constructed to avoid floating-point operations as much as possible — 
to maintain numerical precision — a single division at the end was unavoidable to get the exact intersection coordinates.
I formed a basic linear equation from the two line segments and computed the point of intersection using simple math, 
resulting in a form like x = a / b, y = c / d. The final division is done only once per coordinate.
For cases where shape == 2, this means the two segments are collinear and intersect at an endpoint.
So in that situation, I simply compared the endpoints of both segments to find the shared one and printed it.


##코드 설명 Code

```python
x1, y1, x2, y2 = map(int, input().split())
x3, y3, x4, y4 = map(int, input().split())

def crossed_line(x1, y1, x2, y2, x3, y3, x4, y4):
  # 기울기 분류를 위한 변수
  xDemo_1, xDemo_2 = x2 - x1, x4 - x3
  yDemo_1, yDemo_2 = y2 - y1, y4 - y3

  # 정렬
  def sort_loc(x1, y1, x2, y2, x3, y3, x4, y4):
    if (x1, y1) > (x2, y2):
      x1, y1, x2, y2 = x2, y2, x1, y1
    if (x3, y3) > (x4, y4):
      x3, y3, x4, y4 = x4, y4, x3, y3
    return x1, y1, x2, y2, x3, y3, x4, y4

  # 두 선분의 기울기로 shape 변수 설정
  # shape => 0 : 한점에서 만날수 없음 / 1 : 한점에서 만날수도 있음 / 2 : 한점에서 만남
  if xDemo_1 * yDemo_2 == xDemo_2 * yDemo_1:
    shape = 0
  else:
    shape = 1

  # 계산 함수 
  def calculation(x1, y1, x2, y2, x3, y3, x4, y4, a, b, shape):
    if a > b:
      return False, shape
    # 겹치는 x값의 범위가 한 점이고 같은 y값이 있다면 한점에서 만남
    if a == b:
      if max(y1 ,y2) == min(y3, y4) or max(y3, y4) == min(y1, y2):
        shape = 2
    temp_1 = (y2 - y1) * (a - x1) * (x4 - x3) - (y4 - y3) * (a - x3) * (x2 - x1) + (y1 - y3) * (x2 - x1) * (x4 - x3)
    temp_2 = (y2 - y1) * (b - x1) * (x4 - x3) - (y4 - y3) * (b - x3) * (x2 - x1) + (y1 - y3) * (x2 - x1) * (x4 - x3)
    if temp_1 * temp_2 <= 0:
      return True, shape
    else:
      return False, shape

  # 겹침 판단
  def result(x1, y1, x2, y2, x3, y3, x4, y4, shape):
    extent_x = [max(x1, x3), min(x2, x4)]
    return calculation(x1, y1, x2, y2, x3, y3, x4, y4, extent_x[0], extent_x[1], shape)

  # 두 선분 모두 기울기 = INF 또는 두 선분의 기울기가 각각 INF, 0
  if yDemo_1 == 0 and yDemo_2 == 0 or xDemo_1 == 0 and yDemo_2 == 0 or xDemo_2 == 0 and yDemo_1 == 0:
    x1, y1, x2, y2 = x1 - y1, x1 + y1, x2 - y2, x2 + y2
    x3, y3, x4, y4 = x3 - y3, x3 + y3, x4 - y4, x4 + y4

  # 한 선분만 기울기 INF -> 원점을 기준으로 90도 회전
  elif xDemo_1 == 0 or xDemo_2 == 0:
    x1, y1, x2, y2 = y1, -x1, y2, -x2
    x3, y3, x4, y4 = y3, -x3, y4, -x4

  # 최종 계산
  x1, y1, x2, y2, x3, y3, x4, y4 = sort_loc(x1, y1, x2, y2, x3, y3, x4, y4)
  return(result(x1, y1, x2, y2, x3, y3, x4, y4, shape))

b, shape = crossed_line(x1, y1, x2, y2, x3, y3, x4, y4)
if not b:
    print(0)
else:
    print(1)
    # float 부정확성 개선을 위해 미리 계산해서 나누기는 출력하기전에 한번만 사용
    if shape == 1:
        xloc_under = (y2 - y1) * (x4 - x3) - (y4 - y3) * (x2 - x1)
        xloc_over = x1 * (x4 - x3) * (y2 - y1) - x3 * (x2 - x1) * (y4 - y3) + (y3 - y1) * (x2 - x1) * (x4 - x3)
        yloc_under = (x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1)
        yloc_over = y1 * (x2 - x1) * (y4 - y3) - y3 * (x4 - x3) * (y2 - y1) + (x3 - x1) * (y2 - y1) * (y4 - y3)
        print(xloc_over / xloc_under, yloc_over / yloc_under)
    # 무조건 한점에서 만날떄 그 점을 찾음
    if shape == 2:
      location = [(x3, y3), (x4, y4)]
      for loc in location:
        if loc == (x1, y1):
          print(float(x1), float(y1))
          break
        if loc == (x2, y2):
          print(float(x2), float(y2))
          break


## 예시 입력 Sample Input
0 1 0 0
-10 0 10 0

## 예시 출력 Sample Output
1
-0.0 0.0

## 마무리 Conclusion or Reflection
내가 만든 알고리즘을 조금더 심화해서 더욱 강력한 기능이 있는 코드를 작성했다.
모든 코드를 직접 작성 했기 때문에 이해도도 높았고 흥미도 많이 가는 문제였다.

I enhanced the algorithm I originally created, implementing a more advanced version with stronger capabilities.
Since I wrote all the code myself, I gained a deep understanding of it and found the problem highly engaging.
