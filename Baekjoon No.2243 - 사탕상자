# Baekjoon No.2243 - 사탕상자

- [문제 링크](https://www.acmicpc.net/problem/2243)


## 문제 설명 Problem Description
각각의 사탕은 그 맛의 좋고 나쁨이 1부터 1,000,000까지의 정수로 구분된다. 1이 가장 맛있는 사탕을 의미하며, 1,000,000은 가장 맛없는 사탕을 의미한다.
첫째 줄에 사탕상자에 손을 댄 횟수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 두 정수 A, B, 혹은 세 정수 A, B, C가 주어진다. A가 1인 경우는 사탕상자에서 사탕을 꺼내는 경우이다.
이때에는 한 정수만 주어지며, B는 꺼낼 사탕의 순위를 의미한다. 이 경우 사탕상자에서 한 개의 사탕이 꺼내지게 된다. 또, A가 2인 경우는 사탕을 넣는 경우이다.
이때에는 두 정수가 주어지는데, B는 넣을 사탕의 맛을 나타내는 정수이고 C는 그러한 사탕의 개수이다. C가 양수일 경우에는 사탕을 넣는 경우이고, 음수일 경우에는 빼는 경우이다.
맨 처음에는 빈 사탕상자에서 시작한다고 가정하며, 사탕의 총 개수는 2,000,000,000을 넘지 않는다. 또한 없는 사탕을 꺼내는 경우와 같은 잘못된 입력은 주어지지 않는다.
A가 1인 모든 입력에 대해서, 꺼낼 사탕의 맛의 번호를 출력한다.

Each candy is classified by its taste quality, which is represented by an integer between 1 and 1,000,000.
1 means the most delicious candy.
1,000,000 means the least delicious candy.
You are given an integer n (1 ≤ n ≤ 100,000), the number of times someone interacts with the candy box.
For the next n lines, each line contains either:
One operation with two integers A, B
If A = 1, it means someone wants to take a candy out of the box.
Here, B represents the rank of the candy to take out (for example, if B = 3, you take the 3rd most delicious candy currently in the box).
When this happens, exactly one candy is removed from the box.
One operation with three integers A, B, C
If A = 2, it means someone is putting candies into the box.
B is the taste value of the candy.
C is the number of such candies.
If C > 0, it means you are adding candies.
If C < 0, it means you are removing candies.
At the beginning, the box is empty.
The total number of candies in the box will not exceed 2,000,000,000.
Invalid operations (like trying to take a candy that doesn’t exist) will not occur.
For every operation where A = 1, output the taste value of the candy that gets removed.


## 생각 과정 Thought Process
1. ** 세그먼트 트리 **
처음엔 어떻게 자료구조의 구성을 맞춰야 하나 생각을 했는데 세그먼트 트리의 구성을 사용하면 쉽게 풀수 있으리라 생각했다.
왜냐하면 약 4,000,000개의(MAX(=1,000,000) * 4) int 리스트를 사용할 수 있고 어떤 순위의 개수가 몇개 있는지 종합적으로 빠르게 구할 수 있기 때문이다.

2. ** 쿼리 **
세그먼트 트리를 이용해서 트리를 업데이트 하는 것은 그대로 누적합을 구하면 돼서 쉬웠지만 쿼리를 구하는 것은 꽤나 까다로웠다.
물론 일반적인 세그먼트 트리의 쿼리와 닮았지만 쿼리의 재귀를 어떤 방식으로 사용할지에 대한 의문이 생겼다.
어떻게 첫번쨰 노드에서 범위를 좁힐지 생각을 해 보았는데
[NODE * 2] 와 [NODE * 2 + 1] 는 NODE의 범위를 모두 포함하고 MID를 기점으로 정확히 절반 나뉘므로  이를 이용하여 범위를 나누고자 했다.

1. ** Segment Tree **
At first, I thought about how to design the data structure for this problem, and I realized that using a segment tree would make it easier to solve.
The reason is that we can allocate about 4,000,000 integers (MAX(=1,000,000) * 4) and quickly compute how many candies exist up to any rank by storing cumulative counts efficiently.

2. ** Query **
Updating the tree with the segment tree was straightforward since it’s just about maintaining cumulative sums. However, implementing the query part was quite tricky.
Although it resembles a typical segment tree query, I was unsure how to apply recursion to narrow down the search range.
After some thought, I realized that [NODE * 2] and [NODE * 2 + 1] together cover the entire range of a node and are split exactly in half at MID.
By leveraging this property, I could recursively narrow the search to the correct segment.


##코드 설명 Code

```python
MAX = 1_000_000

# 세그먼트 트리
tree = [0] * (MAX * 4)

# 트리 업데이트
def update(node, start, end, idx, count):
  if idx < start or idx > end:
    return
  tree[node] += count
  if start == end:
    return
  mid = (start + end) // 2
  update(node * 2, start, mid, idx, count)
  update(node * 2 + 1, mid + 1, end, idx, count)

# 쿼리를 구함
def query(node, start, end, target):
  # 발견
  if start == end:
    return start
  mid = (start + end) // 2
  # 해당 순위의 맛들의 절반순위보다 낮다면 좌측 쿼리 탐색
  if tree[node * 2] >= target:
    return query(node * 2, start, mid, target)
  # else - 우측 쿼리 탐색 및 순위 업데이트
  else:
    return query(node * 2 + 1, mid + 1, end, target - tree[node * 2])

n = int(input())
for _ in range(n):
  line = list(map(int, input().split()))
  if line[0] == 1:
    result = query(1, 1, MAX, line[1])
    print(result)
    update(1, 1, MAX, result, -1)
  else:
    update(1, 1, MAX, line[1], line[2])


## 예시 입력 Sample Input
6
2 1 2
2 3 3
1 2
1 2
2 1 -1
1 2

## 예시 출력 Sample Output
1
3
3


## 마무리 Conclusion or Reflection
일반적인 세그먼트 트리 문제였다. 문제 구조상 세그먼트 트리를 떠올리기 개인적으로는 힘들었다. 사실 어떻게 푸는지 조금 참고했다.
쿼리 부분에서 세그먼트 트리의 성질을 이용하여 쿼리를 구했는데 이것도 떠올리는데에 시간이 좀 걸렸다.

In the end, this turned out to be a fairly standard segment tree problem.
 Still, I personally found it difficult to come up with the segment tree approach on my own for this specific problem. To be honest, I had to look up some hints on how to solve it.
The query part, in particular, required me to carefully use the properties of the segment tree, and figuring that out took me some extra time.
