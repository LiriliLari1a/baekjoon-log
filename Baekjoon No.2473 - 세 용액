# Baekjoon No.2473 - μ„Έ μ©μ•΅

- [λ¬Έμ  λ§ν¬](https://www.acmicpc.net/problem/2473)

## λ¬Έμ  μ„¤λ… Problem Description
μ²«μ§Έ μ¤„μ—λ” μ „μ²΄ μ©μ•΅μ μ Nμ΄ μ…λ ¥λλ‹¤. Nμ€ 3 μ΄μƒ 5,000 μ΄ν•μ μ •μμ΄λ‹¤. λ‘μ§Έ μ¤„μ—λ” μ©μ•΅μ νΉμ„±κ°’μ„ λ‚νƒ€λ‚΄λ” Nκ°μ μ •μκ°€ λΉμΉΈμ„ μ‚¬μ΄μ— λ‘κ³  μ£Όμ–΄μ§„λ‹¤. 
μ΄ μλ“¤μ€ λ¨λ‘ -1,000,000,000 μ΄μƒ 1,000,000,000 μ΄ν•μ΄λ‹¤. Nκ°μ μ©μ•΅λ“¤μ νΉμ„±κ°’μ€ λ¨λ‘ λ‹¤λ¥΄κ³ ,μ²«μ§Έ μ¤„μ— νΉμ„±κ°’μ΄ 0μ— κ°€μ¥ κ°€κΉμ΄ μ©μ•΅μ„ λ§λ“¤μ–΄λ‚΄λ” μ„Έ μ©μ•΅μ νΉμ„±κ°’μ„ μ¶λ ¥ν•λ‹¤. 
μ¶λ ¥ν•΄μ•Όν•λ” μ„Έ μ©μ•΅μ€ νΉμ„±κ°’μ μ¤λ¦„μ°¨μμΌλ΅ μ¶λ ¥ν•λ‹¤. νΉμ„±κ°’μ΄ 0μ— κ°€μ¥ κ°€κΉμ΄ μ©μ•΅μ„ λ§λ“¤μ–΄λ‚΄λ” κ²½μ°κ°€ λ‘ κ° μ΄μƒμΌ κ²½μ°μ—λ” κ·Έ μ¤‘ μ•„λ¬΄κ²ƒμ΄λ‚ ν•λ‚λ¥Ό μ¶λ ¥ν•λ‹¤.

You're given a list of N unique liquid values (where 3 β‰¤ π‘ β‰¤ 5000, 3 β‰¤ N β‰¤ 5000), each between -10^9 and 10^9. 
Your task is to find three distinct liquids whose combined value is closest to zero and print their values in ascending order.


## μƒκ° κ³Όμ • Thought Process
1. ** μ •λ ¬ λ° ν¬ ν¬μΈν„° - 1 **
μΌλ‹¨μ€ λ¦¬μ¤νΈμ¤‘ μ„ νƒ ν•λ” λ¬Έμ μ΄λ―€λ΅ ν¬ ν¬μΈν„°λ¥Ό λ¨Όμ € λ– μ¬λ Έλ‹¤. λ‘ μ©μ•΅μ ν•©μ΄λ©΄ μΆ‹κ² μ§€λ§ μ„Έ μ©μ•΅μ ν•©μ΄λΌ μƒκ°μ„ μ΅°κΈ λ” ν•΄λ³΄κ² λμ—λ‹¤.
μ²μμΌλ΅ μ–‘μκ°€ λ“±μ¥ν•λ” κ³³λ¶€ν„°(μ¤‘μ•™μ΄λΌκ³  κ°€μ •) μ—°μ†μΌλ΅ ν¬μΈν„°λ¥Ό μ„Έκ°λ¥Ό μ΅κ³  μ™Όμ½ μΈλ±μ¤μ™€ μ¤λ¥Έμ½ μΈλ±μ¤λ¥Ό μ΅°μ ν•λ©° κµ¬ν„μ„ μ²μμ— ν•΄λ΄¤λ”λ° μμ  μ¶λ ¥μ΄ μ λ€λ΅ λμ§€μ•μ•λ‹¤.

2. ** μ •λ ¬ λ° ν¬ ν¬μΈν„° - 2 **
λ¬Έμ λ¥Ό ν’€μ–΄λ³΄λ©΄μ„ λ­”κ°€ λ²”μ„λΌλ” λ‹¨μ–΄μ— κ½‚νκ² λμ—λ‹¤. κ·Έλμ„ νƒμƒ‰ λ²”μ„λ¥Ό μ¤„μΌ μ μλ” λ¬΄μ–Έκ°€λ¥Ό μ°ΎμΌλ ¤ μ‹λ„ ν–λ‹¤. κ²°κµ­μ—λ” ν¬μΈν„° ν•λ‚λ¥Ό λ¬΄μ΅°κ±΄ μ„ νƒν•λ‹¤ κ°€μ •ν•΄μ„ λ²”μ„λ¥Ό μ¤„μ΄λ” λ°©λ²•μΌλ΅ κ°”λ‹¤.
μ„Έ μ©μ•΅μ λ²νΈ (i, j, k)λ¥Ό μ΅κ³  i κ°’μ΄ 0 λ²μ¨° λ¶€ν„° N - 2 λ²μ§Έ κΉμ§€ ν•λ²μ”© λ¨λ‘ κ³ μ •ν•λ‹¤ μƒκ°ν•κ³  λ‚λ¨Έμ§€ λ‘ μ©μ•΅μ„ ν¬ ν¬μΈν„°λ¥Ό μ μ ν μ›€μ§μ—¬ κµ¬ν„ν–λ‹¤.

1. ** Sorting & Two Pointers - 1 **
Since this is a problem about choosing elements from a list, I first thought of using the two-pointer approach. While it would be ideal for two elements, 
since the goal is to find three elements whose sum is closest to zero, I had to reconsider. 
I initially tried using three pointers starting from the point where positive numbers appear and adjusted the left and right pointers. However, this approach didnβ€™t yield the correct results for the sample cases.

2, ** Sorting & Two Pointers - 2 **
While solving the problem, I became fixated on the idea of narrowing the "range" of the search. 
I decided to fix one element and use two pointers for the remaining elements to reduce complexity. Specifically,
I fixed the first index i from 0 to N - 2, and used two pointers j and k to find the other two elements.


##μ½”λ“ μ„¤λ… Code

```python
N = int(input())
liquid = list(map(int, input().split()))
liquid.sort()

temp = float("inf")   # κ°€μ¥ μµμ  ν•©μ„ μ €μ¥

# i, j, k λ²μ§Έ μ©μ•΅μ„ μ„ νƒ ν–μ„ λ–„(i < j < k)
for i in range(N - 2):
  j, k = i + 1, N - 1
  while j < k:
    total = liquid[i] + liquid[j] + liquid[k]
    if abs(total) < abs(temp):   # λ” μ ν•©ν• κ°’μ„ μ°Ύμ•μ„λ•
      temp = total
      result = [liquid[i], liquid[j], liquid[k]]
    if total > 0:
      k -= 1
    elif total < 0:
      j += 1
    else:   # total == 0
      result = [liquid[i], liquid[j], liquid[k]]
      break
      
print(" ".join(map(str, result)))


## μμ‹ μ…λ ¥ Sample Input
6
-10 0 2 3 4 8

## μμ‹ μ¶λ ¥ Sample Output
-10 2 8


## λ§λ¬΄λ¦¬ Conclusion or Reflection
μ²μμ— κµ¬ν„ν•λ‹¤ μ¤λ¥κ°€ μμ—μ§€λ§ λ²”μ„λΌλ” κ²ƒμ— κ³ μ°°μ„ ν•λ©΄μ„ λ¬Έμ κ°€ μ‰¬μ›μ΅λ‹¤. μ„Έκ°μ ν¬μΈν„°λ¥Ό λ¨λ‘ μ®κΈ°λ©΄ νλ“λ‹ ν•κ°μ ν¬μΈν„°λ¥Ό κ³ μ • μ‹μΌλ†“κ³  λ‚λ¨Έμ§€ ν¬μΈν„°λ¥Ό μ®κΈ°λ©΄ λ²”μ„λ„ μ¤„κ³  μ½”λ“λ„ μ¤„κ² κµ¬λ‚ ν•κ³  μƒκ°ν–λ‹¤.
λ‹¤λ§ μ‹κ°„λ³µμ΅λ„κ°€ κ΄μ°®μ„μ§€ κ±±μ •ν–μ§€λ§ λ„λ„ν•κ² ν†µκ³Όν–λ‹¤.

Initially, I encountered some bugs, but focusing on narrowing the search range made the problem clearer. 
I realized that fixing one pointer and moving the others reduces both the range and the complexity of the code. I was slightly worried about time complexity, but it passed comfortably.
