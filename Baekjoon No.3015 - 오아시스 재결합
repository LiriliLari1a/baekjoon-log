# Baekjoon No.3015 - 오아시스 재결합
- [문제 링크](https://www.acmicpc.net/problem/3015)


## 문제 설명 Problem Description
두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.
줄에 서 있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.
첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)
둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 231 나노미터 보다 작다.
사람들이 서 있는 순서대로 입력이 주어진다.

Two people A and B can see each other if and only if there is no person taller than either A or B standing between them.
You are given the heights of people standing in a line. Write a program to calculate the number of pairs of people who can see each other.
The first line contains an integer N (1 ≤ N ≤ 500,000), the number of people in the line.
The following N lines each contain the height of a person in nanometers.
All heights are less than 2^31nanometers.
The people are given in the order they are standing.
Print the number of pairs of people who can see each other.


## 생각 과정 Thought Process
1. ** 스택 **
이 문제를 해결하는 방법에 대해 생각해 보면서 첫번째 사람과 마지막 사람이 모두 가장 클 때 두 사람이 마주 볼수 있음에 집중했다.
이는 사람들의 키를 하나 씩 처리 할 때 초반에 남아있는 사람들의 가능성도 고려해야 했다.
그래서 모든 사람을 구조에 포함하되 더이상 확인 할 필요가 없는 사람들의 정보는 제거하기로 했다.
그러기에 가장 알맞은 구조는 스택 자료형이었다.

2. ** 프로세스 **
더이상 확인 할 필요가 없는 사람은 무엇일까 생각을 해보면 그 사람의 양측이 모두 큰 사람으로 막혀 볼 수 없는 사람이었다.
따라서 마지막에 스택에 추가된 사람의 키보다 새로운 정보가 크지 않으면 계속 그 정보를 추가하고 그렇지 않다면 새로운 정보보다 작은 값들은 모두 계산하여 pop()한다.

3. ** 계산 **
계산을 위해서 일단 가우스 합공식을 사용하였다.
연속된 같은 값 끼리(개수: count)는 가우스 합공식을 이용하여 계산했고 stack에서 그 연속된 값의 집합을 둘러싸고 있는 값들은 모두 그들보다 큰값이다.
따라서 서있는 좌, 우 각각의 사람과 연속된 모든 값들은 서로 볼 수 있다.
그래서 결과 값이 {(연속된 같은 값의 수 x 2) + (연속된 같은 값의 수의 가우스 합)}이 되었다.

4. ** 경계값 **
그런데 계산 과정에서 문제가 생겼다. 결과 값을 계산할 떄 그 좌측과 우측에 모두 사람이 있을 거란 보장이 없었다.
가장 초반에 입력된 사람의 정보와 마지막에 입력된 사람의 정보로 인해 계산에 오차가 생겼다.
따라서 이 계산값에 대해 일관성을 부여하고자 MAX(=2^31)의 값으로 스택의 양끝에 위치하도록 한 후 경계값과 만나는 개수를 빼기로 했다.
경계값과 만나는 개수는 입력된 정보를 두바퀴만 돌면 되므로 어렵지 않게 구했다.

1. ** Stack **

While thinking about how to solve this problem, I focused on the fact that if both the first and last people are the tallest, then they can see each other.
This led me to realize that when processing each person’s height one by one, I also needed to account for the possibility of the people who remain at the beginning.
So I decided to include everyone in the data structure, but remove those whose information was no longer needed.
The most suitable data structure for this purpose was a stack.

2. ** Process **

Who are the people whose information is no longer needed?
They are the ones who are blocked on both sides by taller people, meaning they cannot see anyone anymore.
Therefore, when a new person’s height is not greater than the last element in the stack, I simply push them onto the stack.
But if the new height is greater, I repeatedly pop and compute all people shorter than the new person.

3. ** Computation **
For the computation, I used the Gauss summation formula.
It didn’t take me too long to come up with the overall idea.
However, turning that mental picture into an actual implementation, simplifying the calculations, and adjusting for errors was not easy.
That part took quite a bit of time—but fortunately, I ended up with an approach similar to the official stack-based solution.
Handling consecutive equal heights:
When consecutive people have the same height (count = number of duplicates), their pairs can be calculated using the Gauss summation formula.
Since the values surrounding this group in the stack are guaranteed to be taller, every person in the group can see the taller people to their left and right.
Therefore, the contribution to the result becomes:
(count×2)+Gauss(count)

4. ** Boundary Values **
But during the computation, a problem arose:
When calculating pairs, there is no guarantee that there will be people on both the left and right sides.
The very first and last people in the input can cause errors in the counting.
To enforce consistency, I added a boundary value MAX = 2³¹ to both ends of the stack.
Then, I subtracted the number of pairs involving these boundary values.
Since the number of such pairs can be found with just two passes over the input, this adjustment was straightforward.


##코드 설명 Code

```python
MAX = 2 ** 31

# 가우스 합 공식(n 개의 조합으로 만들 수 있는 경우의 수)
def calc(n):
  return n * (n - 1) // 2

# 다음 접근 값이 커질 때 stack에서 pop()하며 결과값 계산
def process(result, cur):
  while stack[-1] < cur:
    prev = stack.pop()
    count = 1
    # 같은 값은 함께 계산
    while prev == stack[-1]:
      count += 1
      prev = stack.pop()
    result += 2 * count + calc(count)

  return result

numbers = []
# 모든 정보 스택에 저장
N = int(input())
for _ in range(N):
  numbers.append(int(input()))

# 임의로 설정한 경계값으로 생기는 결과를 제거위함
temp = 2
rising, falling = numbers[0], numbers[N - 1]
for i in range(1, N):
  if rising <= numbers[i]:
    rising = numbers[i]
    temp += 1
  if falling <= numbers[N - 1 - i]:
    falling = numbers[N - 1 - i]
    temp += 1

# 임의의 MAX로 경계값을 만들어 코드를 최적화
stack = [MAX]
result = 0
while numbers:
  cur = numbers.pop()
  # 값이 감소 또는 유지시 스택에 추가
  if cur <= stack[-1]:
    stack.append(cur)
  # 값이 증가시에 그 값보다 작은 값은 모두 스택에서 정리
  else:
    result = process(result, cur)
    stack.append(cur)
# 나머지 값 정리
result = process(result, MAX) - temp

print(result)


## 예시 입력 Sample Input
5
5
2
2
5
5

## 예시 출력 Sample Output
8


## 마무리 Conclusion or Reflection
이 문제를 풀 수 있는 아이디어를 생각하기 까지 그렇게 오래걸리지 않았다.
하지만 머릿속에 있는 이것을 구현하고 계산을 단순화 하고 오차를 조정하는 과정은 쉽지 않았다.
그런탓에 꽤나 시간이 걸렸는데 다행히 정석 풀이와 비슷한 방식으로 풀게 되었다.

It didn’t take me very long to come up with the idea for solving this problem.
However, implementing what I had in mind, simplifying the calculations, and adjusting for errors was not easy.
Because of that, it took me quite some time, but fortunately, I ended up solving it in a way similar to the standard solution.
